import requests

def fetch_token_pools(chain_id, token_address):
    """
    Fetch all pools for a given token address on a specified chain using the DexScreener API.
    Endpoint: /token-pairs/v1/{chainId}//{tokenAddress}
    Example URL for Sonic: https://api.dexscreener.com/token-pairs/v1/sonic//{tokenAddress}
    """
    url = f"https://api.dexscreener.com/token-pairs/v1/{chain_id}//{token_address}"
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        pools = response.json()  # Expected to be a JSON array of pool objects
        return pools
    except Exception as e:
        print("Error fetching token pools:", e)
        return []

def compute_effective_price(pool, token_address_lower):
    """
    Given a pool and the token address (lowercase), determine the effective USD price for that token.
    - If the token is the baseToken, use priceUsd.
    - If the token is the quoteToken, effective price is 1/priceUsd.
    Returns effective price (float) and a string indicating the token position ("base" or "quote").
    """
    try:
        priceUsd = float(pool.get("priceUsd", "0"))
    except Exception:
        return None, None

    base = pool.get("baseToken", {})
    quote = pool.get("quoteToken", {})
    base_addr = base.get("address", "").lower()
    quote_addr = quote.get("address", "").lower()
    
    # If token appears as baseToken
    if token_address_lower == base_addr:
        return priceUsd, "base"
    # If token appears as quoteToken, invert priceUsd (if non-zero)
    elif token_address_lower == quote_addr:
        if priceUsd != 0:
            return 1 / priceUsd, "quote"
        else:
            return None, None
    else:
        # Token not found in this pool (shouldn't happen if filtering by token address)
        return None, None

def report_arbitrage_from_pools(pools, token_address, min_liquidity=10000):
    """
    For a list of pool objects, compute the effective USD price for the given token,
    filtering out pools with liquidity below min_liquidity.
    Then, report the highest and lowest effective prices and the computed percentage difference.
    """
    token_address_lower = token_address.lower()
    effective_prices = []
    
    for pool in pools:
        try:
            liquidity_usd = float(pool.get("liquidity", {}).get("usd", 0))
            if liquidity_usd < min_liquidity:
                continue  # Skip pools with insufficient liquidity

            eff_price, position = compute_effective_price(pool, token_address_lower)
            if eff_price is None:
                continue
            effective_prices.append({
                "dexId": pool.get("dexId", "unknown"),
                "effectivePrice": eff_price,
                "pairAddress": pool.get("pairAddress", "unknown"),
                "liquidityUsd": liquidity_usd,
                "position": position
            })
        except Exception:
            continue

    if len(effective_prices) > 1:
        highest = max(effective_prices, key=lambda x: x["effectivePrice"])
        lowest = min(effective_prices, key=lambda x: x["effectivePrice"])
        if lowest["effectivePrice"] > 0:
            diff_percent = ((highest["effectivePrice"] - lowest["effectivePrice"]) / lowest["effectivePrice"]) * 100
            print("\nArbitrage details for token (pools with liquidity >= ${}):".format(min_liquidity))
            for entry in effective_prices:
                print(f"  DEX: {entry['dexId']} - Effective Price: {entry['effectivePrice']:.6f} USD "
                      f"(Position: {entry['position']}), Liquidity: ${entry['liquidityUsd']:.2f}")
            print(f"  Highest Effective Price: {highest['effectivePrice']:.6f} USD, "
                  f"Lowest Effective Price: {lowest['effectivePrice']:.6f} USD")
            print(f"  Price Difference: {diff_percent:.2f}%\n")
        else:
            print("Lowest effective price is zero, cannot calculate arbitrage.")
    else:
        print("Not enough pool data to compute arbitrage details.")

def main():
    chain_id = "sonic"  # For Sonic chain
    token_address = input("Enter the token address to check pools: ").strip()
    
    print(f"\nFetching pools for token {token_address} on {chain_id}...")
    pools = fetch_token_pools(chain_id, token_address)
    
    if pools:
        print(f"Found {len(pools)} pools for token {token_address}.")
        report_arbitrage_from_pools(pools, token_address, min_liquidity=10000)
    else:
        print("No pool data found.")

if __name__ == "__main__":
    main()
